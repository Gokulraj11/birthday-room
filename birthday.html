<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Birthday Room â€” Prototype</title>
  <style>
    :root{ --bg:#f7f7fb; --card:#ffffff; --accent:#ff5c8a; --topbar-h:64px; --gap:12px; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#111}
    .topbar{position:fixed;left:var(--gap);right:var(--gap);top:var(--gap);z-index:1000;display:flex;align-items:center;gap:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(250,250,252,0.96));box-shadow:0 6px 20px rgba(16,24,40,0.08);backdrop-filter: blur(6px); height:var(--topbar-h);}
    .brand{font-weight:700;font-size:16px;color:#121212;margin-right:6px}
    .controls{display:flex;gap:8px;align-items:center;flex:1}
    .controls > *{background:var(--card);border:1px solid rgba(0,0,0,0.06);padding:8px 10px;border-radius:10px;font-size:14px}
    .controls input[type="text"]{min-width:240px}
    #canvas-wrapper{position:fixed;left:var(--gap);right:var(--gap);top:calc(var(--gap) + var(--topbar-h) + 8px);bottom:var(--gap);border-radius:14px;overflow:hidden;box-shadow:0 16px 60px rgba(16,24,40,0.12);background:linear-gradient(180deg,#ffffff,#fbf7fb)}
    #canvas-container{width:100%;height:100%;display:block}
    button.primary{background:linear-gradient(90deg,var(--accent),#ffa6c9);color:white;border:none}
    button.ghost{background:transparent}
    .debug { position:fixed; left:12px; top:80px; background:rgba(0,0,0,0.6); color:white; padding:6px 10px; border-radius:8px; font-size:12px; z-index:2000 }
    @media (max-width:720px){ .controls input[type="text"]{min-width:120px} .topbar{flex-wrap:wrap;height:auto;padding:10px} #canvas-wrapper{top:calc(var(--gap) + 120px)} }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js"
    }
  }
  </script>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
  <div class="topbar" role="banner">
    <div class="brand">ðŸŽ‚ Birthday Room â€” Prototype</div>
    <div class="controls" id="controls">
      <button id="startBtn" class="primary">Start Camera &amp; Mic</button>
      <button id="resetCake" class="ghost">Reset Cake</button>

      <div id="peerUi" style="display:flex;align-items:center;gap:8px;margin-left:auto">
        <div id="peerIdLabel" style="padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.95);font-weight:600;min-width:180px;text-align:center">Peer: (not ready)</div>
        <input id="callInput" type="text" placeholder="Partner PeerID" style="padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
        <button id="callBtn">Call</button>
        <button id="copyShare" title="Copy my PeerID" style="padding:8px 12px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#ffa6c9);color:white;">Copy ID</button>
      </div>
    </div>
  </div>

  <div id="canvas-wrapper" aria-live="polite">
    <div id="canvas-container"></div>
  </div>

  <div id="debug" class="debug" style="display:none">Debug</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/controls/OrbitControls.js';

    function dbg(text){ const el = document.getElementById('debug'); if(!el) return; el.style.display='block'; el.innerText = text; }

    // --- three setup -------------------------------------------------------
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 2.2, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.4, 0);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    controls.minDistance = 2.0; controls.maxDistance = 7.0;
    controls.minPolarAngle = Math.PI * 0.15; controls.maxPolarAngle = Math.PI * 0.48;
    function clampTarget(){ const t = controls.target; t.x = Math.max(Math.min(t.x, 4), -4); t.y = Math.max(Math.min(t.y, 2.4), 0.8); t.z = Math.max(Math.min(t.z, 1.5), -3.5); controls.target.set(t.x,t.y,t.z); }
    clampTarget(); controls.update();
    controls.addEventListener('change', ()=>{ clampTarget(); const dist = camera.position.distanceTo(controls.target); if(dist < controls.minDistance){ const dir = new THREE.Vector3(); camera.getWorldDirection(dir); camera.position.addScaledVector(dir, -(controls.minDistance - dist)); } if(dist > controls.maxDistance){ const dir = new THREE.Vector3(); camera.getWorldDirection(dir); camera.position.addScaledVector(dir, (dist - controls.maxDistance)); } });

    // --- room, cake, candles -----------------------------------------------
    const room = new THREE.Mesh(new THREE.BoxGeometry(12,6,10), new THREE.MeshStandardMaterial({ color:0xf5f5f5, side: THREE.BackSide })); room.position.y = 3; scene.add(room);
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(12,10), new THREE.MeshStandardMaterial({ color:0xefe6e6 })); floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; floor.position.y = 0; scene.add(floor);
    const hemi = new THREE.HemisphereLight(0xffffee,0x8888ff,0.6); scene.add(hemi);
    const spot = new THREE.PointLight(0xfff7dd,1.1,20); spot.position.set(0,4,2); scene.add(spot);

    const cakeGroup = new THREE.Group();
    const cakeBody = new THREE.Mesh(new THREE.CylinderGeometry(0.9,0.9,0.6,32), new THREE.MeshStandardMaterial({ color:0xffc0cb }));
    cakeBody.position.y = 0.5; cakeGroup.add(cakeBody);
    const cakeTop = new THREE.Mesh(new THREE.CylinderGeometry(0.9,0.9,0.05,32), new THREE.MeshStandardMaterial({ color:0xffffff }));
    cakeTop.position.y = 0.8; cakeGroup.add(cakeTop);
    cakeGroup.position.set(0,0,-1); scene.add(cakeGroup);

    const candles = [];
    const flameSprites = [];
    function createCandles() {
      for (let i = 0; i < 5; i++) {
        const theta = (i / 5) * Math.PI * 2;
        const x = Math.cos(theta) * 0.3;
        const z = Math.sin(theta) * 0.3;
        const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.25, 12), new THREE.MeshStandardMaterial({ color: 0xffffff }));
        candle.position.set(x, 0.95, z - 1); scene.add(candle); candles.push(candle);

        const cvs = document.createElement('canvas'); cvs.width = 64; cvs.height = 64; const ctx = cvs.getContext('2d');
        const g = ctx.createRadialGradient(32, 16, 4, 32, 32, 32); g.addColorStop(0, 'rgba(255,255,200,1)'); g.addColorStop(0.4, 'rgba(255,140,0,0.95)'); g.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(32, 22, 10, 16, 0, 0, Math.PI * 2); ctx.fill();
        const map = new THREE.CanvasTexture(cvs);
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map, depthWrite: false })); sprite.scale.set(0.18, 0.28, 1); sprite.position.set(x, 1.08, z - 1); scene.add(sprite); flameSprites.push(sprite);
      }
    }
    createCandles();

    let candlesLit = true;
    function extinguishCandles() { if (!candlesLit) return; candlesLit = false; let t = 1; const fade = () => { t -= 0.06; flameSprites.forEach(s => s.material.opacity = Math.max(0, t)); if (t > 0) requestAnimationFrame(fade); else { flameSprites.forEach(s => s.visible = false); showHappyText(); startConfetti(); } }; fade(); }
    function resetCandles() { candlesLit = true; flameSprites.forEach(s => { s.visible = true; s.material.opacity = 1 }); stopConfetti(); hideHappyText(); }

    const happyDiv = document.createElement('div');
    happyDiv.style.position = 'absolute'; happyDiv.style.left = '50%'; happyDiv.style.top = '6%'; happyDiv.style.transform = 'translateX(-50%)';
    happyDiv.style.fontSize = '44px'; happyDiv.style.fontWeight = '700'; happyDiv.style.color = 'crimson'; happyDiv.style.textShadow = '0 6px 18px rgba(0,0,0,0.25)'; happyDiv.style.display = 'none'; happyDiv.innerText = 'HAPPY BIRTHDAY ðŸŽ‰';
    document.getElementById('canvas-wrapper').appendChild(happyDiv);
    function showHappyText() { happyDiv.style.display = 'block'; } function hideHappyText() { happyDiv.style.display = 'none'; }

    // Confetti
    let confettiParticles = null, confettiRunning = false;
    function startConfetti() { if (confettiRunning) return; confettiRunning = true; confettiParticles = []; for (let i = 0; i < 120; i++) { confettiParticles.push({ x: (Math.random() - 0.5) * 3, y: 3.2, z: (Math.random() - 0.5) * 3, vx: (Math.random() - 0.5) * 0.06, vy: -0.01 - Math.random() * 0.03, rot: Math.random() * Math.PI, color: `hsl(${Math.random() * 360},70%,60%)` }); } }
    function stopConfetti() { confettiRunning = false; confettiParticles = null; }
    function drawConfetti() { if (!confettiRunning) return; confettiParticles.forEach(p => { p.x += p.vx; p.y += p.vy; p.rot += 0.2; if (p.y < 0.05) p.y = 0.05; const s = 0.04; const mat = new THREE.MeshBasicMaterial({ color: p.color }); const geo = new THREE.PlaneGeometry(s, s * 1.6); const mesh = new THREE.Mesh(geo, mat); mesh.position.set(p.x, p.y, p.z); mesh.rotation.y = p.rot; scene.add(mesh); setTimeout(() => { scene.remove(mesh); geo.dispose(); mat.dispose(); }, 40); }); }

    // Video panels (local preview)
    const videoEl = document.createElement('video'); videoEl.autoplay = true; videoEl.muted = true; videoEl.playsInline = true;
    const videoTexture = new THREE.VideoTexture(videoEl);
    videoTexture.minFilter = THREE.LinearFilter; videoTexture.magFilter = THREE.LinearFilter; videoTexture.format = THREE.RGBAFormat; videoTexture.generateMipmaps = false;
    const aniso = renderer.capabilities.getMaxAnisotropy(); if (aniso) videoTexture.anisotropy = aniso;

    // side-by-side portrait screens on back wall (fixed size)
    let screenW = 1.4, screenH = 2.6, gap = 0.35;
    const localPreview = new THREE.Mesh(new THREE.PlaneGeometry(screenW, screenH), new THREE.MeshBasicMaterial({ map: videoTexture, toneMapped: false, side: THREE.DoubleSide }));
    localPreview.position.set(-screenW / 2 - gap, 1.6, -4.85); localPreview.rotation.y = Math.PI; scene.add(localPreview);

    const remoteScreen = new THREE.Mesh(new THREE.PlaneGeometry(screenW, screenH), new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide }));
    remoteScreen.position.set(screenW / 2 + gap, 1.6, -4.85); remoteScreen.rotation.y = Math.PI; remoteScreen.visible = false; scene.add(remoteScreen);

    // name badges
    const nameTagLeft = document.createElement('div'); nameTagLeft.style.position = 'fixed'; nameTagLeft.style.left = '16px'; nameTagLeft.style.bottom = '16px'; nameTagLeft.style.padding = '6px 10px'; nameTagLeft.style.borderRadius = '12px'; nameTagLeft.style.background = 'rgba(255,255,255,0.9)'; nameTagLeft.innerText = 'You'; document.body.appendChild(nameTagLeft);
    const nameTagRight = document.createElement('div'); nameTagRight.style.position = 'fixed'; nameTagRight.style.right = '16px'; nameTagRight.style.bottom = '16px'; nameTagRight.style.padding = '6px 10px'; nameTagRight.style.borderRadius = '12px'; nameTagRight.style.background = 'rgba(255,255,255,0.9)'; nameTagRight.innerText = 'Her (waiting)'; document.body.appendChild(nameTagRight);

    // --- audio blow detection ------------------------------------------------
    let audioCtx, analyser, micStream; let blowCooldown = false;
    function startAudioProcessing(stream) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      micStream = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser(); analyser.fftSize = 1024;
      micStream.connect(analyser);
      const data = new Uint8Array(analyser.frequencyBinCount);
      let history = [], lastTrigger = 0, warmupSamples = 0;
      const WARMUP_REQUIRED = 30, MIN_ABSOLUTE = 30, SUSTAIN_FRAMES = 2; let consecSpike = 0;

      function analyze() {
        try { analyser.getByteFrequencyData(data); } catch(e){ requestAnimationFrame(analyze); return; }
        let sum = 0; for (let i=0;i<data.length;i++){ sum += data[i]*data[i]; }
        const rms = Math.sqrt(sum / data.length);
        if (warmupSamples < WARMUP_REQUIRED) { history.push(rms); if (history.length > WARMUP_REQUIRED) history.shift(); warmupSamples++; requestAnimationFrame(analyze); return; }
        history.push(rms); if (history.length > 60) history.shift();
        const baseline = history.reduce((a,b)=>a+b,0)/history.length;
        const now = Date.now(); const sensitivity = 2.6;
        const isSpike = rms > Math.max(MIN_ABSOLUTE, baseline * sensitivity);
        if (isSpike) consecSpike++; else consecSpike = 0;
        if (!blowCooldown && consecSpike >= SUSTAIN_FRAMES && (now - lastTrigger) > 1200) {
          lastTrigger = now; blowCooldown = true;
          extinguishCandles();
          try { if (dataConn && dataConn.open) dataConn.send({ type: 'blow' }); } catch (e) { console.warn('Failed to send blow event', e); }
          setTimeout(()=>{ blowCooldown = false; }, 2000);
        }
        requestAnimationFrame(analyze);
      }
      for (let i=0;i<6;i++) history.push(8);
      analyze();
    }

    // --- PeerJS integration --------------------------------------------------
    let peer = null, localStream = null, dataConn = null, currentCall = null, lowLatencyMode = false;
    window._br_state = { peerRef: () => peer, currentCallRef: () => currentCall };

    const peerIdLabel = document.getElementById('peerIdLabel'); const callInput = document.getElementById('callInput'); const callBtn = document.getElementById('callBtn');
    const remoteVideo = document.createElement('video'); remoteVideo.autoplay = true; remoteVideo.playsInline = true; remoteVideo.muted = true; remoteVideo.style.display = 'none'; document.body.appendChild(remoteVideo);

    function handleDataMessage(msg){ try{ if(!msg) return; if(typeof msg === 'string'){ try{ msg = JSON.parse(msg); }catch(e){} } if(msg && msg.type === 'blow'){ extinguishCandles(); } }catch(e){ console.warn('Data message error', e); } }

    window.__remoteVideoTexture = null;

    // Preferred media constraints (high quality)
    const HIGH_CONSTRAINTS = { video: { width: { ideal: 1280, min: 640 }, height: { ideal: 720 }, aspectRatio: 16/9, frameRate: { ideal: 30 } }, audio: true };
    const LOW_CONSTRAINTS = { video: { width: { ideal: 640 }, height: { ideal: 360 }, frameRate: { ideal: 15 } }, audio: true };

    async function getPreferredStream(preferLow = false) {
      const constraints = preferLow ? LOW_CONSTRAINTS : HIGH_CONSTRAINTS;
      try {
        const s = await navigator.mediaDevices.getUserMedia(constraints);
        return s;
      } catch (e) {
        console.warn('getUserMedia failed for preferred constraints, falling back to simpler', e);
        try { return await navigator.mediaDevices.getUserMedia({ video: true, audio: true }); } catch (err) { throw err; }
      }
    }

    // Robust applyRemoteStream: wait for frames, handle AbortError, avoid creating texture too early
    function applyRemoteStream(videoElem) {
      try { videoElem.style.display = 'none'; videoElem.playsInline = true; } catch(e){}
      try {
        const fixedW = screenW, fixedH = screenH;
        if (remoteScreen && remoteScreen.geometry) { remoteScreen.geometry.dispose(); remoteScreen.geometry = new THREE.PlaneGeometry(fixedW, fixedH); }
        remoteScreen.rotation.y = Math.PI;
        remoteScreen.position.y = 1.6;
        remoteScreen.visible = false;
      } catch(e) { console.warn('remoteScreen setup failed', e); }

      function videoLooksPlayable(v){
        try { const hasTracks = !!(v.srcObject && v.srcObject.getTracks && v.srcObject.getTracks().length); return hasTracks && v.readyState > 2 && v.videoWidth > 0 && v.videoHeight > 0; } catch(e) { return false; }
      }

      function attachTexture() {
        try {
          if (!videoLooksPlayable(videoElem)) {
            console.warn('attachTexture: video not playable yet', { readyState: videoElem.readyState, vw: videoElem.videoWidth, vh: videoElem.videoHeight, tracks: videoElem.srcObject ? videoElem.srcObject.getTracks().length : 0 });
            return false;
          }
          if (window.__remoteVideoTexture) { try { window.__remoteVideoTexture.dispose(); } catch(e){} window.__remoteVideoTexture = null; }
          window.__remoteVideoTexture = new THREE.VideoTexture(videoElem);
          window.__remoteVideoTexture.minFilter = THREE.LinearFilter;
          window.__remoteVideoTexture.magFilter = THREE.LinearFilter;
          window.__remoteVideoTexture.format = THREE.RGBAFormat;
          window.__remoteVideoTexture.generateMipmaps = false;
          const an = renderer.capabilities.getMaxAnisotropy(); if (an) window.__remoteVideoTexture.anisotropy = an;
          if (remoteScreen && remoteScreen.material) { remoteScreen.material.map = window.__remoteVideoTexture; remoteScreen.material.needsUpdate = true; remoteScreen.visible = true; }
          if (nameTagRight) nameTagRight.innerText = 'Her (live)';
          console.log('attachTexture: VideoTexture attached (dims)', videoElem.videoWidth, videoElem.videoHeight);
          return true;
        } catch(err) { console.warn('attachTexture failed', err); return false; }
      }

      // retry-safe play wrapper
      let playAttempts = 0;
      async function tryPlayUntilPlayable(maxAttempts = 6, delayMs = 300) {
        playAttempts++;
        try {
          await videoElem.play();
          return true;
        } catch (err) {
          const isAbort = err && (err.name === 'AbortError' || /abort/i.test(String(err)));
          const isNotAllowed = err && (err.name === 'NotAllowedError' || /not allowed/i.test(String(err)));
          console.warn(`video.play() attempt ${playAttempts} rejected:`, err && err.name ? err.name : err, isAbort ? '(Abort)' : '', isNotAllowed ? '(NotAllowed/autoplay policy)' : '');
          if (isNotAllowed) return false;
          if (playAttempts < maxAttempts) {
            await new Promise(r => setTimeout(r, delayMs));
            return tryPlayUntilPlayable(maxAttempts, delayMs);
          }
          return false;
        }
      }

      if (videoLooksPlayable(videoElem)) {
        try { if (videoElem.muted !== true) videoElem.muted = true; tryPlayUntilPlayable().then(() => attachTexture()); return; } catch(e) { console.warn('immediate playable attach error', e); }
      }

      let attached = false;
      const onPlayable = () => {
        if (attached) return;
        attached = true;
        setTimeout(() => {
          try { if (videoElem.muted !== true) videoElem.muted = true; } catch(e){}
          tryPlayUntilPlayable().then(_ => {
            if (!attachTexture()) console.warn('onPlayable: attachTexture returned false (video still not ready)');
          });
        }, 80);
        cleanup();
      };
      const cleanup = () => {
        videoElem.removeEventListener('loadeddata', onPlayable);
        videoElem.removeEventListener('canplay', onPlayable);
        videoElem.removeEventListener('playing', onPlayable);
      };

      videoElem.addEventListener('loadeddata', onPlayable, { once: true });
      videoElem.addEventListener('canplay', onPlayable, { once: true });
      videoElem.addEventListener('playing', onPlayable, { once: true });

      try {
        const prevMuted = videoElem.muted;
        videoElem.muted = true;
        const p = videoElem.play && videoElem.play();
        if (p && typeof p.catch === 'function') {
          p.catch(err => {
            console.warn('initial video.play() rejected (caught), will attempt retries via tryPlayUntilPlayable', err && err.name ? err.name : err);
          });
        }
      } catch(e) { console.warn('video.play() thrown', e); }

      setTimeout(() => {
        if (!attached) {
          attached = true;
          console.warn('applyRemoteStream: fallback timeout reached, attempting attach');
          tryPlayUntilPlayable(2, 300).then(() => {
            if (!attachTexture()) console.warn('fallback attach failed (video not playable)');
          });
          cleanup();
        }
      }, 3000);
    }

    // helper: attach remote stream and ensure frames arrive; if not, attempt a single re-call
    async function handleIncomingRemoteStream(remoteStream, callerPeerId) {
      try { remoteVideo.srcObject = remoteStream; } catch (e) { console.warn('attach srcObject failed', e); }
      applyRemoteStream(remoteVideo);

      const MAX_TOTAL_WAIT = 8000; const PLAY_RETRY_INTERVAL = 350; const STABLE_REQUIRED = 2; // increased timeout
      let stable = 0; const start = Date.now();
      async function tryPlayOnce() { try { await remoteVideo.play(); return true; } catch (err) { return false; } }

      while (Date.now() - start < MAX_TOTAL_WAIT) {
        if (remoteVideo.videoWidth > 0 && remoteVideo.videoHeight > 0 && remoteVideo.readyState > 2) { stable++; if (stable >= STABLE_REQUIRED) { console.log('Remote video playable: ', remoteVideo.videoWidth, 'x', remoteVideo.videoHeight); return true; } } else { stable = 0; }
        await tryPlayOnce().catch(()=>{});
        await new Promise(r => setTimeout(r, PLAY_RETRY_INTERVAL));
      }

      console.warn('Remote frames did not arrive within timeout. Attempting one re-call for', callerPeerId);
      try {
        if (currentCall && typeof currentCall.close === 'function') { try { currentCall.close(); } catch(e) { console.warn('error closing currentCall', e); } currentCall = null; }
        if (!dataConn || dataConn.peer !== callerPeerId) { try { dataConn = peer.connect(callerPeerId); } catch(e){ console.warn('dataConn reconnect failed', e); } }
        if (peer && callerPeerId && localStream) {
          const newCall = peer.call(callerPeerId, localStream);
          currentCall = newCall;
          newCall.on('stream', s => { remoteVideo.srcObject = s; applyRemoteStream(remoteVideo); handleIncomingRemoteStream(s, callerPeerId); });
          newCall.on('error', e => console.warn('re-call error', e));
          await new Promise(r => setTimeout(r, 3500));
          if (remoteVideo.videoWidth > 0) { console.log('Re-call succeeded, frames arrived.'); return true; } else { console.warn('Re-call did not produce frames.'); }
        }
      } catch (err) { console.warn('re-call attempt failed', err); }

      console.warn('Final: remoteVideo state', { readyState: remoteVideo.readyState, videoWidth: remoteVideo.videoWidth, videoHeight: remoteVideo.videoHeight, tracks: remoteVideo.srcObject ? remoteVideo.srcObject.getTracks().map(t=>({kind:t.kind,enabled:t.enabled,readyState:t.readyState})) : null, peerExists: !!window.peer, currentCallExists: !!window.currentCall });
      return false;
    }

    // createPeer helper (PeerJS)
    async function createPeer(){
      if(peer) return peer;
      const PeerCtor = window.Peer || window.peer || null;
      if (!PeerCtor) { peerIdLabel.innerText = 'PeerJS not loaded'; console.warn('PeerJS missing'); return null; }
      try { peer = new PeerCtor(); window._br_state.peer = peer; } catch(e) { console.warn('Peer creation failed', e); peerIdLabel.innerText = 'Peer init failed'; return null; }

      peer.on('open', id => {
        peerIdLabel.innerText = 'Your PeerID: ' + id;
        const copyBtn = document.getElementById('copyShare');
        if (copyBtn) copyBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(id); copyBtn.innerText = 'Copied!'; setTimeout(()=>copyBtn.innerText='Copy ID',1200); }catch(e){ console.warn('Copy failed', e); } });
      });

      // handle incoming call â€” ensure we have a high-res local stream before answering
      async function handleCallAsync(call) {
        currentCall = call; window._br_state.currentCall = currentCall;
        console.log('Incoming call from', call.peer);
        try {
          if (!localStream) {
            // request preferred high-res stream before answering
            try { const s = await getPreferredStream(false); localStream = s; videoEl.srcObject = s; await videoEl.play().catch(()=>{}); startAudioProcessing(s); if (startBtn) { startBtn.disabled = true; startBtn.innerText = 'Camera & Mic Running'; } }
            catch(e) { console.warn('Failed to get local stream before answering', e); }
          }
        } catch(e) { console.warn('pre-answer stream error', e); }

        if (localStream) call.answer(localStream);
        call.on('stream', remoteStream => { handleIncomingRemoteStream(remoteStream, call.peer); });
        call.on('close', ()=>{ if (currentCall === call) currentCall = null; });
      }

      peer.on('call', call => { handleCallAsync(call); });

      peer.on('connection', conn => {
        console.log('Data connection from', conn.peer);
        dataConn = conn;
        dataConn.on('open', ()=>{});
        dataConn.on('data', d => handleDataMessage(d));
        dataConn.on('close', ()=>{ if (dataConn && dataConn.peer === conn.peer) dataConn = null; });
      });

      peer.on('error', err => { console.warn('Peer error', err); peerIdLabel.innerText = 'Peer error'; });
      peer.on('disconnected', ()=>{ peerIdLabel.innerText = 'Peer disconnected'; });
      return peer;
    }

    // low/high latency helpers (replace tracks)
    async function switchToLowLatency(){
      try{
        const low = await getPreferredStream(true);
        if(currentCall && currentCall.peerConnection){ const senders = currentCall.peerConnection.getSenders(); const v = low.getVideoTracks()[0]; const a = low.getAudioTracks()[0]; senders.forEach(s => { try{ if(s.track && s.track.kind==='video' && v) s.replaceTrack(v); if(s.track && s.track.kind==='audio' && a) s.replaceTrack(a); }catch(e){} }); }
        videoEl.srcObject = low; localStream = low; return true;
      }catch(e){ console.warn('Low-latency failed', e); return false; }
    }

    async function restoreHighLatency(){
      try{
        const high = await getPreferredStream(false);
        if(currentCall && currentCall.peerConnection){ const senders = currentCall.peerConnection.getSenders(); const v = high.getVideoTracks()[0]; const a = high.getAudioTracks()[0]; senders.forEach(s => { try{ if(s.track && s.track.kind==='video' && v) s.replaceTrack(v); if(s.track && s.track.kind==='audio' && a) s.replaceTrack(a); }catch(e){} }); }
        videoEl.srcObject = high; localStream = high; return true;
      }catch(e){ console.warn('Restore high failed', e); return false; }
    }

    // wire start button
    const startBtn = document.getElementById('startBtn');
    if (startBtn) startBtn.addEventListener('click', async ()=> {
      try {
        // request the preferred high-resolution stream (C: higher-res negotiation)
        const stream = await getPreferredStream(false);
        videoEl.srcObject = stream; await videoEl.play().catch(()=>{});
        startAudioProcessing(stream);
        localStream = stream; startBtn.disabled = true; startBtn.innerText = 'Camera & Mic Running';
        await createPeer(); dbg('Peer initialized');
      } catch(e) { alert('Camera/Mic access failed: ' + (e && e.message)); }
    });

    // handle call button
    const callBtnEl = document.getElementById('callBtn');
    if (callBtnEl) callBtnEl.addEventListener('click', async ()=> {
      const otherId = (callInput && callInput.value ? callInput.value.trim() : '');
      if (!otherId) return alert('Enter partner PeerID');
      if (!localStream) return alert('Start camera first');
      await createPeer();
      try {
        const call = peer.call(otherId, localStream);
        currentCall = call; window._br_state.currentCall = currentCall;
        call.on('stream', remoteStream => { handleIncomingRemoteStream(remoteStream, call.peer); });
        call.on('close', ()=>{ if (currentCall === call) currentCall = null; });
        if (!dataConn || dataConn.peer !== otherId) {
          const conn = peer.connect(otherId);
          dataConn = conn; dataConn.on('open', ()=>{}); dataConn.on('data', d => handleDataMessage(d)); dataConn.on('close', ()=>{ if (dataConn && dataConn.peer === otherId) dataConn = null; });
        }
      } catch(e) { console.warn('Call failed', e); alert('Call failed: ' + (e && e.message)); }
    });

    // reset cake
    const resetBtn = document.getElementById('resetCake'); if(resetBtn) resetBtn.addEventListener('click', ()=> resetCandles());

    // resize handler
    window.addEventListener('resize', ()=>{ const w = container.clientWidth; const h = container.clientHeight; camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); });

    // animation loop
    function animate(){
      requestAnimationFrame(animate);
      if (candlesLit) { flameSprites.forEach((s,i)=>{ s.position.y = 1.06 + Math.sin(Date.now()*0.007 + i) * 0.01; }); }
      try { if (window.__remoteVideoTexture) window.__remoteVideoTexture.needsUpdate = true; } catch(e) {}
      drawConfetti(); renderer.render(scene, camera);
    }
    animate();

    // Expose helpful debug functions to console
    window.__br_debug = {
      listVideos: () => Array.from(document.querySelectorAll('video')).map((v,i)=>({idx:i, readyState:v.readyState, width:v.videoWidth, height:v.videoHeight, paused:v.paused, muted:v.muted, tracks: v.srcObject ? v.srcObject.getTracks().map(t=>({kind:t.kind,enabled:t.enabled})) : null})),
      hasRemoteTexture: () => !!window.__remoteVideoTexture,
      showDebug: (msg) => dbg(msg)
    };
  </script>
</body>
</html>
