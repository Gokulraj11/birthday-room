<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3D Birthday Room â€” Prototype</title>
  <style>
    :root{ --bg:#f7f7fb; --card:#ffffff; --accent:#ff5c8a; --topbar-h:64px; --gap:12px; }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#111}
    .topbar{position:fixed;left:var(--gap);right:var(--gap);top:var(--gap);z-index:1000;display:flex;align-items:center;gap:12px;padding:12px;border-radius:12px;background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(250,250,252,0.96));box-shadow:0 6px 20px rgba(16,24,40,0.08);backdrop-filter: blur(6px); height:var(--topbar-h);}
    .brand{font-weight:700;font-size:16px;color:#121212;margin-right:6px}
    .controls{display:flex;gap:8px;align-items:center;flex:1}
    .controls > *{background:var(--card);border:1px solid rgba(0,0,0,0.06);padding:8px 10px;border-radius:10px;font-size:14px}
    .controls input[type="text"]{min-width:240px}
    #canvas-wrapper{position:fixed;left:var(--gap);right:var(--gap);top:calc(var(--gap) + var(--topbar-h) + 8px);bottom:var(--gap);border-radius:14px;overflow:hidden;box-shadow:0 16px 60px rgba(16,24,40,0.12);background:linear-gradient(180deg,#ffffff,#fbf7fb)}
    #canvas-container{width:100%;height:100%;display:block}
    button.primary{background:linear-gradient(90deg,var(--accent),#ffa6c9);color:white;border:none}
    button.ghost{background:transparent}
    .debug { position:fixed; left:12px; top:80px; background:rgba(0,0,0,0.6); color:white; padding:6px 10px; border-radius:8px; font-size:12px; z-index:2000 }
    @media (max-width:720px){ .controls input[type="text"]{min-width:120px} .topbar{flex-wrap:wrap;height:auto;padding:10px} #canvas-wrapper{top:calc(var(--gap) + 120px)} }
  </style>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js"
    }
  }
  </script>

  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
</head>
<body>
  <div class="topbar" role="banner">
    <div class="brand">ðŸŽ‚ Birthday Room â€” Prototype</div>
    <div class="controls" id="controls">
      <button id="startBtn" class="primary">Start Camera &amp; Mic</button>
      <button id="resetCake" class="ghost">Reset Cake</button>

      <div id="peerUi" style="display:flex;align-items:center;gap:8px;margin-left:auto">
        <div id="peerIdLabel" style="padding:6px 10px;border-radius:8px;background:rgba(255,255,255,0.95);font-weight:600;min-width:180px;text-align:center">Peer: (not ready)</div>
        <input id="callInput" type="text" placeholder="Partner PeerID" style="padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06)" />
        <button id="callBtn">Call</button>
        <button id="copyShare" title="Copy my PeerID" style="padding:8px 12px;border-radius:8px;background:linear-gradient(90deg,var(--accent),#ffa6c9);color:white;">Copy ID</button>
      </div>
    </div>
  </div>

  <div id="canvas-wrapper" aria-live="polite">
    <div id="canvas-container"></div>
  </div>

  <div id="debug" class="debug" style="display:none">Debug</div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/controls/OrbitControls.js';

    function dbg(text){ const el = document.getElementById('debug'); if(!el) return; el.style.display='block'; el.innerText = text; }

    // --- three setup -------------------------------------------------------
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 2.2, 5);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.4, 0);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    controls.minDistance = 2.0; controls.maxDistance = 7.0;
    controls.minPolarAngle = Math.PI * 0.15; controls.maxPolarAngle = Math.PI * 0.48;
    function clampTarget(){ const t = controls.target; t.x = Math.max(Math.min(t.x, 4), -4); t.y = Math.max(Math.min(t.y, 2.4), 0.8); t.z = Math.max(Math.min(t.z, 1.5), -3.5); controls.target.set(t.x,t.y,t.z); }
    clampTarget(); controls.update(); controls.addEventListener('change', ()=>{ clampTarget(); const dist = camera.position.distanceTo(controls.target); if(dist < controls.minDistance){ const dir = new THREE.Vector3(); camera.getWorldDirection(dir); camera.position.addScaledVector(dir, -(controls.minDistance - dist)); } if(dist > controls.maxDistance){ const dir = new THREE.Vector3(); camera.getWorldDirection(dir); camera.position.addScaledVector(dir, (dist - controls.maxDistance)); } });

    // --- room, cake, candles -----------------------------------------------
    const room = new THREE.Mesh(new THREE.BoxGeometry(12,6,10), new THREE.MeshStandardMaterial({ color:0xf5f5f5, side: THREE.BackSide })); room.position.y = 3; scene.add(room);
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(12,10), new THREE.MeshStandardMaterial({ color:0xefe6e6 })); floor.rotation.x = -Math.PI/2; floor.receiveShadow = true; floor.position.y = 0; scene.add(floor);
    scene.add(new THREE.HemisphereLight(0xffffee,0x8888ff,0.6));
    const spot = new THREE.PointLight(0xfff7dd,1.1,20); spot.position.set(0,4,2); scene.add(spot);

    const cakeGroup = new THREE.Group();
    const cakeBody = new THREE.Mesh(new THREE.CylinderGeometry(0.9,0.9,0.6,32), new THREE.MeshStandardMaterial({ color:0xffc0cb })); cakeBody.position.y = 0.5; cakeGroup.add(cakeBody);
    const cakeTop = new THREE.Mesh(new THREE.CylinderGeometry(0.9,0.9,0.05,32), new THREE.MeshStandardMaterial({ color:0xffffff })); cakeTop.position.y = 0.8; cakeGroup.add(cakeTop);
    cakeGroup.position.set(0,0,-1); scene.add(cakeGroup);

    const candles = [], flameSprites = [];
    function createCandles(){
      for(let i=0;i<5;i++){
        const theta = (i/5)*Math.PI*2; const x = Math.cos(theta)*0.3; const z = Math.sin(theta)*0.3;
        const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,0.25,12), new THREE.MeshStandardMaterial({ color:0xffffff }));
        candle.position.set(x,0.95,z-1); scene.add(candle); candles.push(candle);
        const cvs = document.createElement('canvas'); cvs.width=64; cvs.height=64; const ctx = cvs.getContext('2d'); const g = ctx.createRadialGradient(32,16,4,32,32,32); g.addColorStop(0,'rgba(255,255,200,1)'); g.addColorStop(0.4,'rgba(255,140,0,0.95)'); g.addColorStop(1,'rgba(255,100,0,0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.ellipse(32,22,10,16,0,0,Math.PI*2); ctx.fill(); const map = new THREE.CanvasTexture(cvs); const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map, depthWrite:false })); sprite.scale.set(0.18,0.28,1); sprite.position.set(x,1.08,z-1); scene.add(sprite); flameSprites.push(sprite);
      }
    }
    createCandles();

    let candlesLit = true;
    function extinguishCandles(){ if(!candlesLit) return; candlesLit=false; let t=1; const fade = ()=>{ t -= 0.06; flameSprites.forEach(s=>s.material.opacity = Math.max(0,t)); if(t>0) requestAnimationFrame(fade); else { flameSprites.forEach(s=>s.visible=false); showHappyText(); startConfetti(); } }; fade(); }
    function resetCandles(){ candlesLit=true; flameSprites.forEach(s=>{ s.visible = true; s.material.opacity = 1 }); stopConfetti(); hideHappyText(); }

    const happyDiv = document.createElement('div'); happyDiv.style.position='absolute'; happyDiv.style.left='50%'; happyDiv.style.top='6%'; happyDiv.style.transform='translateX(-50%)'; happyDiv.style.fontSize='44px'; happyDiv.style.fontWeight='700'; happyDiv.style.color='crimson'; happyDiv.style.textShadow='0 6px 18px rgba(0,0,0,0.25)'; happyDiv.style.display='none'; happyDiv.innerText='HAPPY BIRTHDAY ðŸŽ‰'; document.getElementById('canvas-wrapper').appendChild(happyDiv); function showHappyText(){ happyDiv.style.display='block'; } function hideHappyText(){ happyDiv.style.display='none'; }

    // confetti (lightweight particle spawn)
    let confettiParticles = null, confettiRunning = false;
    function startConfetti(){ if(confettiRunning) return; confettiRunning=true; confettiParticles = []; for(let i=0;i<120;i++){ confettiParticles.push({ x:(Math.random()-0.5)*3, y:3.2, z:(Math.random()-0.5)*3, vx:(Math.random()-0.5)*0.06, vy:-0.01-Math.random()*0.03, rot:Math.random()*Math.PI, color:`hsl(${Math.random()*360},70%,60%)` }); } }
    function stopConfetti(){ confettiRunning=false; confettiParticles=null; }
    function drawConfetti(){ if(!confettiRunning) return; confettiParticles.forEach(p=>{ p.x += p.vx; p.y += p.vy; p.rot += 0.2; if(p.y < 0.05) p.y = 0.05; const s = 0.04; const mat = new THREE.MeshBasicMaterial({ color: p.color }); const geo = new THREE.PlaneGeometry(s,s*1.6); const mesh = new THREE.Mesh(geo, mat); mesh.position.set(p.x,p.y,p.z); mesh.rotation.y = p.rot; scene.add(mesh); setTimeout(()=>{ scene.remove(mesh); geo.dispose(); mat.dispose(); }, 40); }); }

    // --- video textures & screens (back wall) --------------------------------
    const videoEl = document.createElement('video'); videoEl.autoplay = true; videoEl.muted = true; videoEl.playsInline = true;
    const videoTexture = new THREE.VideoTexture(videoEl); videoTexture.minFilter = THREE.LinearFilter; videoTexture.magFilter = THREE.LinearFilter; videoTexture.format = THREE.RGBAFormat; videoTexture.generateMipmaps = false; const aniso = renderer.capabilities.getMaxAnisotropy(); if(aniso) videoTexture.anisotropy = aniso;

    // two side-by-side portrait screens on back wall
    let screenW = 1.4, screenH = 2.6, gap = 0.35;
    const localPreview = new THREE.Mesh(new THREE.PlaneGeometry(screenW, screenH), new THREE.MeshBasicMaterial({ map: videoTexture, toneMapped:false, side:THREE.DoubleSide }));
    localPreview.position.set(-screenW/2 - gap, 1.6, -4.85); localPreview.rotation.y = Math.PI; scene.add(localPreview);
    const remoteScreen = new THREE.Mesh(new THREE.PlaneGeometry(screenW, screenH), new THREE.MeshBasicMaterial({ color:0x000000, side:THREE.DoubleSide }));
    remoteScreen.position.set(screenW/2 + gap, 1.6, -4.85); remoteScreen.rotation.y = Math.PI; scene.add(remoteScreen);

    // name badges
    const nameTagLeft = document.createElement('div'); nameTagLeft.style.position='fixed'; nameTagLeft.style.left='16px'; nameTagLeft.style.bottom='16px'; nameTagLeft.style.padding='6px 10px'; nameTagLeft.style.borderRadius='12px'; nameTagLeft.style.background='rgba(255,255,255,0.9)'; nameTagLeft.innerText='You'; document.body.appendChild(nameTagLeft);
    const nameTagRight = document.createElement('div'); nameTagRight.style.position='fixed'; nameTagRight.style.right='16px'; nameTagRight.style.bottom='16px'; nameTagRight.style.padding='6px 10px'; nameTagRight.style.borderRadius='12px'; nameTagRight.style.background='rgba(255,255,255,0.9)'; nameTagRight.innerText='Her'; document.body.appendChild(nameTagRight);

    // --- audio blow detection ------------------------------------------------
    let audioCtx, analyser, micStream; let blowCooldown = false;
    function startAudioProcessing(stream) {
      // Warm-up the microphone analyzer to avoid false triggers when enabling mic/camera
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      micStream = audioCtx.createMediaStreamSource(stream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 1024;
      micStream.connect(analyser);
      const data = new Uint8Array(analyser.frequencyBinCount);

      let history = [];
      let lastTrigger = 0;
      let warmupSamples = 0;
      const WARMUP_REQUIRED = 30; // number of frames to collect baseline (~0.5 - 1s)
      const MIN_ABSOLUTE = 30; // small absolute floor to ignore tiny noises
      const SUSTAIN_FRAMES = 2; // require spike to appear for N consecutive frames
      let consecSpike = 0;

      function analyze() {
        try {
          analyser.getByteFrequencyData(data);
        } catch (e) {
          // If context suspended/expired, skip
          requestAnimationFrame(analyze);
          return;
        }

        let sum = 0;
        for (let i = 0; i < data.length; i++) { sum += data[i] * data[i]; }
        const rms = Math.sqrt(sum / data.length);

        // warm-up: collect baseline samples before enabling detection
        if (warmupSamples < WARMUP_REQUIRED) {
          history.push(rms);
          if (history.length > WARMUP_REQUIRED) history.shift();
          warmupSamples++;
          // don't trigger during warmup
          requestAnimationFrame(analyze);
          return;
        }

        // compute baseline as rolling average
        history.push(rms);
        if (history.length > 60) history.shift();
        const baseline = history.reduce((a, b) => a + b, 0) / history.length;

        const now = Date.now();
        const sensitivity = 2.6;

        // require both an absolute threshold and relative spike above baseline
        const isSpike = rms > Math.max(MIN_ABSOLUTE, baseline * sensitivity);

        if (isSpike) consecSpike++; else consecSpike = 0;

        // only trigger when spike sustained for SUSTAIN_FRAMES and cooldown elapsed
        if (!blowCooldown && consecSpike >= SUSTAIN_FRAMES && (now - lastTrigger) > 1200) {
          lastTrigger = now;
          blowCooldown = true;

          // extinguish locally and notify peer
          extinguishCandles();
          try { if (dataConn && dataConn.open) { dataConn.send({ type: 'blow' }); } } catch (e) { console.warn('Failed to send blow event', e); }

          setTimeout(() => { blowCooldown = false; }, 2000);
        }

        requestAnimationFrame(analyze);
      }

      // initialize history with a few quiet values to make baseline reasonable
      for (let i = 0; i < 6; i++) history.push(8);
      analyze();
    }

    // --- PeerJS integration --------------------------------------------------
    let peer = null, localStream = null, dataConn = null, currentCall = null, lowLatencyMode = false;
    const peerIdLabel = document.getElementById('peerIdLabel'); const callInput = document.getElementById('callInput'); const callBtn = document.getElementById('callBtn');

    const remoteVideo = document.createElement('video'); remoteVideo.autoplay = true; remoteVideo.playsInline = true; remoteVideo.muted = false; remoteVideo.style.display = 'none'; document.body.appendChild(remoteVideo);

    function handleDataMessage(msg){ try{ if(!msg) return; if(typeof msg === 'string'){ try{ msg = JSON.parse(msg); }catch(e){} } if(msg && msg.type === 'blow'){ extinguishCandles(); } }catch(e){ console.warn('Data message error', e); } }

    // Single declaration only: remote video texture tracker
    let __remoteVideoTexture = null;
    let __remoteVideoPlaying = false;

    function ensureUnmuteButton() {
      if (document.getElementById('unmuteRemoteBtn')) return;
      const b = document.createElement('button');
      b.id = 'unmuteRemoteBtn';
      b.innerText = 'Unmute Remote';
      b.style.position = 'fixed';
      b.style.top = '80px';
      b.style.right = '12px';
      b.style.zIndex = 3000;
      b.style.padding = '6px 8px';
      b.style.borderRadius = '8px';
      b.style.background = 'rgba(0,0,0,0.6)';
      b.style.color = 'white';
      b.addEventListener('click', () => { try { remoteVideo.muted = false; b.remove(); } catch(e){ console.warn(e); } });
      document.body.appendChild(b);
    }

    function applyRemoteStream(videoElem){
      // Hide floating preview and attach video to remoteScreen plane
      try{ videoElem.style.display = 'none'; videoElem.playsInline = true; videoElem.muted = true; }catch(e){}

      const onMeta = ()=>{
        try{
          const vw = videoElem.videoWidth || 1; const vh = videoElem.videoHeight || 1; const aspect = vw / vh;
          const desiredWidth = screenW; const desiredHeight = desiredWidth / aspect;
          if(remoteScreen && remoteScreen.geometry){ remoteScreen.geometry.dispose(); remoteScreen.geometry = new THREE.PlaneGeometry(desiredWidth, desiredHeight); }
          remoteScreen.rotation.y = Math.PI; remoteScreen.position.y = 1.6;

          if(__remoteVideoTexture){ __remoteVideoTexture.dispose(); __remoteVideoTexture = null; }
          __remoteVideoTexture = new THREE.VideoTexture(videoElem);
          __remoteVideoTexture.minFilter = THREE.LinearFilter; __remoteVideoTexture.magFilter = THREE.LinearFilter;
          __remoteVideoTexture.format = THREE.RGBAFormat; __remoteVideoTexture.generateMipmaps = false;
          const a2 = renderer.capabilities.getMaxAnisotropy(); if(a2) __remoteVideoTexture.anisotropy = a2;

          remoteScreen.material.map = __remoteVideoTexture; remoteScreen.material.needsUpdate = true; remoteScreen.visible = true;
          nameTagRight.innerText = 'Her (live)';
        }catch(err){ console.warn('applyRemoteStream meta error', err); }
      };

      try{ videoElem.removeEventListener('loadedmetadata', onMeta); }catch(e){}
      videoElem.addEventListener('loadedmetadata', onMeta, { once:true });
      try{ videoElem.play().catch(()=>{}); }catch(e){}
      ensureUnmuteButton();
    }

    async function createPeer(){
      if(peer) return peer;
      const PeerCtor = window.Peer || window.peer || null;
      if(!PeerCtor){ peerIdLabel.innerText = 'PeerJS not loaded'; console.warn('PeerJS missing'); return null; }
      try{ peer = new PeerCtor(); }catch(e){ console.warn('Peer creation failed', e); peerIdLabel.innerText = 'Peer init failed'; return null; }

      peer.on('open', id => {
        peerIdLabel.innerText = 'Your PeerID: ' + id;
        const copyBtn = document.getElementById('copyShare');
        if(copyBtn){ copyBtn.addEventListener('click', async ()=>{ try{ await navigator.clipboard.writeText(id); copyBtn.innerText = 'Copied!'; setTimeout(()=>copyBtn.innerText='Copy ID',1200); }catch(e){ console.warn('Copy failed', e); } }); }
      });

      peer.on('call', call => {
        currentCall = call;
        console.log('Incoming call from', call.peer);
        if(localStream) call.answer(localStream);
        call.on('stream', remoteStream => { remoteVideo.srcObject = remoteStream; applyRemoteStream(remoteVideo); });
        call.on('close', ()=>{ if(currentCall === call) currentCall = null; });
      });

      peer.on('connection', conn => {
        console.log('Data connection from', conn.peer);
        dataConn = conn;
        dataConn.on('open', ()=>{});
        dataConn.on('data', d => handleDataMessage(d));
        dataConn.on('close', ()=>{ if(dataConn && dataConn.peer === conn.peer) dataConn = null; });
      });

      peer.on('error', err => { console.warn('Peer error', err); peerIdLabel.innerText = 'Peer error'; });
      peer.on('disconnected', ()=>{ peerIdLabel.innerText = 'Peer disconnected'; });
      return peer;
    }

    async function switchToLowLatency(){
      try{
        const low = await navigator.mediaDevices.getUserMedia({ video: { width:{ ideal:640 }, height:{ ideal:360 }, frameRate:{ ideal:15 } }, audio:true });
        if(currentCall && currentCall.peerConnection){ const senders = currentCall.peerConnection.getSenders(); const v = low.getVideoTracks()[0]; const a = low.getAudioTracks()[0]; senders.forEach(s => { try{ if(s.track && s.track.kind==='video' && v) s.replaceTrack(v); if(s.track && s.track.kind==='audio' && a) s.replaceTrack(a); }catch(e){} }); }
        videoEl.srcObject = low; localStream = low; return true;
      }catch(e){ console.warn('Low-latency failed', e); return false; }
    }

    async function restoreHighLatency(){
      try{
        const high = await navigator.mediaDevices.getUserMedia({ video: { width:{ ideal:1280 }, height:{ ideal:720 }, frameRate:{ ideal:30 } }, audio:true });
        if(currentCall && currentCall.peerConnection){ const senders = currentCall.peerConnection.getSenders(); const v = high.getVideoTracks()[0]; const a = high.getAudioTracks()[0]; senders.forEach(s => { try{ if(s.track && s.track.kind==='video' && v) s.replaceTrack(v); if(s.track && s.track.kind==='audio' && a) s.replaceTrack(a); }catch(e){} }); }
        videoEl.srcObject = high; localStream = high; return true;
      }catch(e){ console.warn('Restore high failed', e); return false; }
    }

    // wire low-latency button if present
    const lowBtn = document.getElementById('lowLatencyBtn');
    if(lowBtn){ lowBtn.addEventListener('click', async ()=>{ lowLatencyMode = !lowLatencyMode; lowBtn.innerText = lowLatencyMode ? 'Low Latency: ON' : 'Low Latency: OFF'; if(lowLatencyMode) await switchToLowLatency(); else await restoreHighLatency(); }); }

    const startBtn = document.getElementById('startBtn');
    if(startBtn){ startBtn.addEventListener('click', async ()=>{
      try{
        const stream = await navigator.mediaDevices.getUserMedia({ video:{ width:{ ideal:1280 }, height:{ ideal:720 }, frameRate:{ ideal:30 } }, audio:true });
        videoEl.srcObject = stream; await videoEl.play(); startAudioProcessing(stream); localStream = stream; startBtn.disabled = true; startBtn.innerText = 'Camera & Mic Running';
        await createPeer(); dbg('Peer initialized');
      }catch(e){ alert('Camera/Mic access failed: ' + (e && e.message)); }
    }); }

    // handle outgoing calls
    const callBtnEl = document.getElementById('callBtn');
    if(callBtnEl){ callBtnEl.addEventListener('click', async ()=>{
      const otherId = (callInput && callInput.value ? callInput.value.trim() : '');
      if(!otherId) return alert('Enter partner PeerID');
      if(!localStream) return alert('Start camera first');
      await createPeer();
      try{
        const call = peer.call(otherId, localStream);
        currentCall = call;
        call.on('stream', remoteStream => { remoteVideo.srcObject = remoteStream; applyRemoteStream(remoteVideo); });
        call.on('close', ()=>{ if(currentCall === call) currentCall = null; });
        // establish data connection
        if(!dataConn || dataConn.peer !== otherId){ const conn = peer.connect(otherId); dataConn = conn; dataConn.on('open', ()=>{}); dataConn.on('data', d=>handleDataMessage(d)); dataConn.on('close', ()=>{ if(dataConn && dataConn.peer === otherId) dataConn = null; }); }
      }catch(e){ console.warn('Call failed', e); alert('Call failed: ' + (e && e.message)); }
    }); }

    // copy peer id button handled in createPeer
    const resetBtn = document.getElementById('resetCake'); if(resetBtn) resetBtn.addEventListener('click', ()=> resetCandles());

    // simple resize
    window.addEventListener('resize', ()=>{ const w = container.clientWidth; const h = container.clientHeight; camera.aspect = w/h; camera.updateProjectionMatrix(); renderer.setSize(w,h); });

    // animation loop
    function animate(){
      requestAnimationFrame(animate);
      if(candlesLit){ flameSprites.forEach((s,i)=>{ s.position.y = 1.06 + Math.sin(Date.now()*0.007 + i) * 0.01; }); }
      // update remote video texture if present
      try{ if(typeof __remoteVideoTexture !== 'undefined' && __remoteVideoTexture) { __remoteVideoTexture.needsUpdate = true; } }catch(e){}
      drawConfetti(); renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
